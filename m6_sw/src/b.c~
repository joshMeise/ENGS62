/*
 * Josh Meise, ENGS 62, Module 1 Step 8
 *
 * This uses modified code provided by Professor Taylor.
 *
 * blinky.c -- toggles LED when 0 is entered by user.
 *
 * Assumes the LED's are connected to AXI_GPIO_0, on channel 1
 *
 * Terminal Settings:
 *  -Baud: 115200
 *  -Data bits: 8
 *  -Parity: no
 *  -Stop bits: 1
 */

// Library inclusions.
#include <stdio.h>
#include "xil_types.h"
#include "platform.h"
#include <xgpio.h>
#include "xparameters.h"
#include <string.h>
#include <stdlib.h>
#include "led.h"
#include "io.h"
#include "servo.h"
#include "gic.h"
#include "adc.h"
#include <unistd.h>

// Predefined constants.
#define CONFIGURE 0
#define PING 1
#define UPDATE 2
#define SERVO_MIN 2.5
#define SERVO_MAX 11

// Structure definition for a ping message.
typedef struct {
	int type;
	int id;
} ping_t;

// Structure definition for update message.
typedef struct {
	int type;
	int id;
	int value;
} update_t;

// Structure definition for update response.
typedef struct {
	int type;
	int id;
	int average;
	int values[30];
} update_response_t;

// Global variables.
static bool done = false;
static XUartPs UART0;
static XUartPs UART1;
static u8 mode;
static u8 numBytes;
static u8 i;
static update_response_t updateResponse;
static ping_t pingResponse;

/*
 * This function handles button pushes appropriately.
 * Inputs: button that was pushed.
 * Outputs: none.
 */
void btn_callback(u32 btn) {
	// Variable declarations.
	char ping[8] = "[PING]\r\n";
	char update[10] = "[UPDATE]\r\n";
	ping_t pingStruct;
	update_t updateStruct;
	float val;

	// Turn off all LEDs.
	led_set(ALL, LED_OFF);

	// Turn on the relevant LED if not LED 3;
	if (btn != 3)
		led_set(btn, LED_ON);

	// Switch modes based on which button is pressed.
	if (btn == 0) {
		mode = CONFIGURE;
	} else if (btn == 1) {
		mode = PING;

		// Fill in the fields of the ping structure.		
		pingStruct.type = PING;
		pingStruct.id = 17;

		// Print out the relevant command.
		XUartPs_Send(&UART1, (u8 *)ping, 8);

		// Sen the ping to the wifi module.
		XUartPs_Send(&UART0, (u8 *)&pingStruct, sizeof(ping_t));
		
	}
	else if (btn == 2) {
		mode = UPDATE;

		// Print out the relevant command.
		XUartPs_Send(&UART1, (u8 *)update, 10);

		// Get the potentiometer value.
		val = adc_get_pot();

		// Fill in the fields of the update message.
		updateStruct.type = UPDATE;
		updateStruct.id = 17;
		updateStruct.value = (int)(val*100);

		// Send the message to UART 0;
		XUartPs_Send(&UART0, (u8 *)&updateStruct, sizeof(update_t));

	}
	else if (btn == 3) {
		done = true;
	}

}

/* 
 * Handles interrupts by invoking built-in interrupt handler.
 * Inputs: Pointer to UART instance.
 * Outputs: None.
 */
void interruptHandler(void *devP) {
	// Variable declarations and coercion.
	XUartPs *dev = (XUartPs *)devP;

	XUartPs_InterruptHandler(dev);

}

/*
 * Handles interrupts on UART0.
 * Inputs: Pointer to instance of UART0; interrupt event; data from event.
 * Outputs: None.
 */
void handler0(void *CallBackRef, u32 Event, u32 EventData) {
	// Variable declarations.
	u8 buff, j;
	u32 num;
	int val;

	// depending on mode treat interrupt from wifi module differently.
	if (mode == CONFIGURE) {
		// If the interrupt on UART0 was a receive event.
		if (Event == XUARTPS_EVENT_RECV_DATA) {
			// Receive the data on UART0.
			num = XUartPs_Recv((XUartPs *)CallBackRef, &buff, 1);

			// Send the data to UART1 to be printed on screen.
			XUartPs_Send(&UART1, &buff, num);
		}
	} else if (mode == PING) {
		// If the interrupt on UART0 was a receive event.
		if (Event == XUARTPS_EVENT_RECV_DATA) {
			// Receive the data on UART0, placing into different parts of the ping depending on what was received.
			if (numBytes == 0)
				num = XUartPs_Recv((XUartPs *)CallBackRef, (u8 *)(&pingResponse.type), 1);
			else if (numBytes == 4)
				num = XUartPs_Recv((XUartPs *)CallBackRef, (u8 *)(&pingResponse.id), 1);
			else
				num = XUartPs_Recv((XUartPs *)CallBackRef, (u8 *)&buff, 1);

			// Increase the number of bytes received.
			numBytes++;

			// Once an entire message has been received.
			if (numBytes == sizeof(ping_t)) {
				// Send the data to UART1.
				printf("Type: %d, ID: %d\r\n", pingResponse.type, pingResponse.id);

				// Reset the number of bytes received.
				numBytes = 0;

			}
		}
	}
	else if (mode == UPDATE) {
		// If the interrupt on UART0 was a receive event.
		if (Event == XUARTPS_EVENT_RECV_DATA) {
			// Receive the data on UART0, placing into different parts of the ping depending on what was received.
			if (numBytes == 0)
				num = XUartPs_Recv((XUartPs *)CallBackRef, (u8 *)(&updateResponse.type), 1);
			else if (numBytes == 4)
				num = XUartPs_Recv((XUartPs *)CallBackRef, (u8 *)(&updateResponse.id), 1);
			else if (numBytes == 8)
				num = XUartPs_Recv((XUartPs *)CallBackRef, (u8 *)(&updateResponse.average), 1);
			else if (numBytes%4 == 0) {
				num = XUartPs_Recv((XUartPs *)CallBackRef, (u8 *)(&updateResponse.values[i]), 1);
				i++;
			}
			else
				num = XUartPs_Recv((XUartPs *)CallBackRef, (u8 *)&buff, 1);

			// Increment the number of bytes.
			numBytes++;

			// Once a full message has been received.
			if (numBytes == sizeof(update_response_t)) {
				// Print messgage to screen.
				printf("Type: %d, ID: %d, Average: %d, Values: {", updateResponse.type, updateResponse.id, updateResponse.average);

				for (j = 0; j < 30; j++) {
					printf("%d ", updateResponse.values[j]);
				}

				printf("}\r\n");

				val = updateResponse.values[updateResponse.id];

				// Send servo to position of the potentiometer.
				servo_set(SERVO_MIN + (SERVO_MAX - SERVO_MIN)*(double)val/100);

				// Reset counters.
				numBytes = 0;
				i = 0;
			}
		}
	}
}

/*
 * Handles interrupts on UART1.
 * Inputs: Pointer to instance of UART1; interrupt event; data from event.
 * Outputs: None.
 */
void handler1(void *CallBackRef, u32 Event, u32 EventData) {
	// Variable declarations.
	u8 buff;
	u32 num;

	// If in configure mode; echo back onto screen.
	if (mode == CONFIGURE) {
		// Check event type.
		if (Event == XUARTPS_EVENT_RECV_DATA) {
			// Receive data on UART1.
			num = XUartPs_Recv((XUartPs *)CallBackRef, &buff, 1);
			// Send data to UART0.
			XUartPs_Send(&UART0, &buff, num);
		}
	} else {
		// Check event type.
		if (Event == XUARTPS_EVENT_RECV_DATA) {
			// Receive and place into buffer.
			num = XUartPs_Recv((XUartPs *)CallBackRef, (u8 *)&buff, 1);
		}
	}
}

int main() {
	// Variable declarations.
	XUartPs_Config *conf;

	// Variable initializations.
	numBytes = 0;
	i = 0;
	
	// Initialize hardware platform.
	init_platform();

	// Set stdin unbuffered, forcing getchar to return immediately when a character is typed.
	setvbuf(stdin,NULL,_IONBF,0);

	// Initialize the gic.
	if (gic_init() != XST_SUCCESS)
		printf("Error initializing gic.\n");

	// Look up the config of the UART.
	conf = XUartPs_LookupConfig(XPAR_PS7_UART_1_DEVICE_ID);

	// Initialize the UART.
	if (XUartPs_CfgInitialize(&UART1, conf, conf->BaseAddress) != XST_SUCCESS)
		printf("Error initializing UART1.\n");

	// Disable the UART.
	XUartPs_DisableUart(&UART1);

	// Set the baud rate.
	if (XUartPs_SetBaudRate(&UART1, 115200) != XST_SUCCESS)
		printf("Error setting BAUD rate.\n");

	// Set the fifo threshod.
	XUartPs_SetFifoThreshold(&UART1, 1);

	// Set the interrupt handler.
	XUartPs_SetInterruptMask(&UART1, XUARTPS_IXR_RXOVR);

	// Set the handler.
	XUartPs_SetHandler(&UART1, handler1, (void *)&UART1);

	// Connect interrupt handler to gic.
	if (gic_connect(XPAR_XUARTPS_1_INTR, interruptHandler, (void *)&UART1) != XST_SUCCESS)
		printf("Connecting interrupt not successful.\n");

	// Enable the UART.
	XUartPs_EnableUart(&UART1);

	// Look up the config of the UART.
	conf = XUartPs_LookupConfig(XPAR_PS7_UART_0_DEVICE_ID);

	// Initialize the UART.
	if (XUartPs_CfgInitialize(&UART0, conf, conf->BaseAddress) != XST_SUCCESS)
		printf("Error initializing UART0.\n");

	// Disable the UART.
	XUartPs_DisableUart(&UART0);

	// Set the baud rate.
	if (XUartPs_SetBaudRate(&UART0, 9600) != XST_SUCCESS)
		printf("Error setting BAUD rate.\n");

	// Set the fifo threshod.
	XUartPs_SetFifoThreshold(&UART0, 1);

	// Set the interrupt handler.
	XUartPs_SetInterruptMask(&UART0, XUARTPS_IXR_RXOVR);

	// Set the handler.
	XUartPs_SetHandler(&UART0, handler0, (void *)&UART0);

	// Connect interrupt handler to gic.
	if (gic_connect(XPAR_XUARTPS_0_INTR, interruptHandler, (void *)&UART0) != XST_SUCCESS)
		printf("Connecting interrupt not successful.\n");

	// Enable the UART.
	XUartPs_EnableUart(&UART0);

	// Initialize the LED module.
	led_init();

	// Initialize interrupts on button.
	io_btn_init(btn_callback);
	
	// Initialize servomotor module.
	servo_init();

	// Initialise ADC
	adc_init();

	printf("[Hello]\n");
	sleep(1);
	
	// Loop through until button 3 is pressed.
	while (!done) {
		sleep(1);
	}
	
	printf("[done]\n");

	sleep(1);
	
	// Shut down the gic.
	gic_close();

	// Clean up hardware platform.
	cleanup_platform();


/*

	// Initialise the servomotor module.
	servo_init();

	// Initialize the adc module.
	adc_init();

	// Initialize the ttc at frequency 1Hz.
	ttc_init(1, timer_callback);

	// Initialize interrupts on button.
	io_btn_init(btn_callback);

	// Initialize interrupts on switches.
	io_sw_init(swt_callback);

	// Start the timer.
	ttc_start();

	// Start out at 7.5% duty cycle.
	dutyCycle = 7.5;

	// Obtain input from user while not q.
	do {
		// Print out the command prompt.
		printf(">");
		
		// Start at the beginning of the string.
		i = 0;
		
		// Read in the string until the user enters a newline.
		while ((c = getchar()) != '\r') {
			
			// Please character into string.
			str[i] = c;
			
			// Move forward in string.
			i++;
		}
		
		// Insert null terminator.
		str[i] = '\0';
		
		printf("%s\n", str);
		
		// Check to see if only a 0 to change LED status.
		if ((str[0] >= '0' && str[0] <= '3') && str[1] == '\0') {
			// Convert to a long.
			num = strtol(str, &jnk, 10);
			
			// Get status of led and print.
			if (led_get(num) == LED_ON)
				printf("[%ld off]\n", num);
			else if (led_get(num) == LED_OFF)
				printf("[%ld on]\n", num);

			// Toggle the LED.
			led_toggle(num);

		}
		// Check to see if colored LED.
		else if ((str[0] == 'r' || str[0] == 'g' || str[0] == 'b' || str[0] == 'y') && str[1] == '\0') {
			// Turn on relevant color.
			if (str[0] == 'r')
				led_set(RED + 5, LED_ON);
			else if (str[0] == 'y')
				led_set(YELLOW + 5, LED_ON);
			else if (str[0] == 'g')
				led_set(GREEN + 5, LED_ON);
			else if (str[0] == 'b')
				led_set(BLUE + 5, LED_ON);
		}
		// Check if adding or subtracting duty cycle.
		else if ((str[0] == 'a' || str[0] == 's') && str[1] == '\0') {
			// If adding or subtracting.
			if (str[0] == 'a')
				dutyCycle += 0.25;
			else
				dutyCycle -= 0.25;

			// Check bounds.
			if (dutyCycle < SERVO_MIN)
				dutyCycle = SERVO_MIN;
			else if (dutyCycle > SERVO_MAX)
				dutyCycle = SERVO_MAX;

			// Print out duty cycle.
			printf("[%lf]\n", dutyCycle);

			// CHange duty cycle.
			servo_set(dutyCycle);
		}
		// Check if low or high.
		else if (strcmp("low", str) == 0) {
			// Set servo to min.
			servo_set(SERVO_MIN);

			dutyCycle = SERVO_MIN;
		}
		else if (strcmp("high", str) == 0) {
			// Set servo to min.
			servo_set(SERVO_MAX);

			dutyCycle = SERVO_MAX;
		}
		
	} while (str[0] != 'q' || str[1] != '\0');

	// Stop the timer.
	ttc_stop();

	// Close the interrupts on switches and buttons.
	io_btn_close();
	io_sw_close();

	// Close down the timer.
	ttc_close();

	// Close the gic.
	gic_close();

	// Turn off LED 4 and all other LEDs.
	led_set(4, LED_OFF);
	led_set(ALL, LED_OFF);
*/
	
	return 0;
}



